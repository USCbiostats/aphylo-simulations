#' Read New Hampshire eXtended format for trees
#' @param fn Full path to the tree file
#' @return A list with the following elements:
#' - tree An object of class `ape`
#' - edge Edge annotations (length and other annotations)
#' - nhx A list of annotations NHX
read_nhx <- function(fn) {
  text <- readLines(fn)
  
  # This pattern catches most of the information
  pattern <- "([(,)])([a-zA-Z0-9_]*)([:][0-9]+[.]?[0-9]*)(\\[&&NHX[a-zA-Z0-9_:=]+\\])?"
  
  # Capturing the patterns and splitting the data
  x <- gregexpr(text, pattern = pattern, perl = TRUE)
  x <- regmatches(text, x)
  
  # Creating a matrix with the data
  x <- regmatches(x[[1]], regexec(x[[1]], pattern = pattern, perl = TRUE))
  x <- do.call(rbind, x)
  
  # Do all have ids?
  noid <- which(x[,3] == "")
  if (length(noid)) {
    x[noid,3] <- sprintf("unnamed%04i", 1:length(noid))
  }
  
  for (i in noid) {
    text <- sub(
      pattern     = x[i,1],
      replacement = paste0(x[i,2:4], collapse = ""),
      x           = text,
      fixed       = TRUE
    )
  }
  
  # Is there any root?
  text <- sub(
    pattern = "[)][;]$", replacement = ")root;", x = text, perl = TRUE
  )
  
  dat <- x[,-c(1L, 2L)]
  
  # Capturing NHX fields
  nhx <- strsplit(dat[,3], split = "[:]|[=]")
  nhx <- tryCatch(lapply(nhx, function(n) {
    if (length(n) > 0) {
      n <- gsub(pattern = "(^\\[|\\]$)", replacement = "", x = n)
      n <- matrix(n[-1], ncol = 2, byrow = TRUE)
      structure(.Data = n[,2], names = n[,1])
    } else
      n
  }), error = function(e) e)
  
  if (inherits(nhx, "error")) 
    stop(
      "There was a problem when processing the &&NHS blocks.",
      " Possibly, not all the attributes have the right tag. Here is the error",
      ":\n", paste0(nhx, collapse=""), call. = FALSE
    )
  
  list(
    tree = ape::read.tree(text = text),
    edge = dat[,-3L],
    nhx  = nhx
  )
  
}

#' Read PLI files from sifter
#' @param fn Full path to the file
#' @return A data table object including the following columns:
#' - name: Used to match UniProtKB data and GOA,
#' - number,
#' - go: A list of the GO annotations
#' - moc: Evidence code
#' - fam: Name of the family
read_pli <- function(fn) {
  
  ans <- xml2::as_list(xml2::read_html(fn))
  res <- lapply(ans$html$body$family[-1], function(b) {
    name   <- b$proteinname
    number <- b$proteinnumber
    go     <- b$gonumber
    moc    <- b$moc
    
    nann <- max(1, length(go))
    
    data.table::data.table(
      name   = rep(unname(name), nann),
      number = rep(unname(number), nann),
      go     = if (is.null(go)) NA else unname(as.vector(go)),
      moc    = if (is.null(moc)) NA else unname(as.vector(moc))
    )
    
  })
  
  do.call(rbind, res)
  
}

